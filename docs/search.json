[
  {
    "objectID": "posts/connectome-cloud-analytics/index.html",
    "href": "posts/connectome-cloud-analytics/index.html",
    "title": "Large-Scale Connectome Analytics in the Cloud",
    "section": "",
    "text": "Learn how to access and analyze large-scale connectome datasets hosted on BrainCircuits.io remotely in Python using DuckDB."
  },
  {
    "objectID": "posts/connectome-cloud-analytics/index.html#goals",
    "href": "posts/connectome-cloud-analytics/index.html#goals",
    "title": "Large-Scale Connectome Analytics in the Cloud",
    "section": "",
    "text": "Learn how to access and analyze large-scale connectome datasets hosted on BrainCircuits.io remotely in Python using DuckDB."
  },
  {
    "objectID": "posts/connectome-cloud-analytics/index.html#requirements",
    "href": "posts/connectome-cloud-analytics/index.html#requirements",
    "title": "Large-Scale Connectome Analytics in the Cloud",
    "section": "Requirements",
    "text": "Requirements\nWe need to first install DuckDB into our Python environment\npip install duckdb"
  },
  {
    "objectID": "posts/connectome-cloud-analytics/index.html#datasets",
    "href": "posts/connectome-cloud-analytics/index.html#datasets",
    "title": "Large-Scale Connectome Analytics in the Cloud",
    "section": "Datasets",
    "text": "Datasets\nEvery dataset on BrainCircuits.io has a unique string identifier. You can find the identifier in the Dataset Description overview or by inspecting the folders of the source data directly.\nFor the following tutorial we are going to use the public fruitfly FlyWire dataset with identifier fruitfly_fafb_flywire_public. Please make sure to cite the appropriate publications when using this data. You can find relevant links in the About widget of the dataset."
  },
  {
    "objectID": "posts/connectome-cloud-analytics/index.html#data-model-overview",
    "href": "posts/connectome-cloud-analytics/index.html#data-model-overview",
    "title": "Large-Scale Connectome Analytics in the Cloud",
    "section": "Data Model Overview",
    "text": "Data Model Overview\nThe static connectome dataset consists of a number of Parquet files. You can see all the files for the FlyWire dataset here: https://api.braincircuits.io/data/fruitfly_fafb_flywire_public/\nIn each dataset folder, you find a DATASET.txt file which shows for all files the contained columns and data type of the column together with the total number of records available.\nThe following table describes briefly the content of each type of file:\n\n\n\n\n\n\n\nFilename\nContent\n\n\n\n\nneurons.parquet\nEach neuron (or segment) in the dataset with an arbitrary set of columns with more information about individual neurons\n\n\nsegment_link.parquet\nAn aggregate edge table that lists the synaptic counts between source and target segments. Additional columns with some statistics about the connection (e.g. avg_scores is the average score value of each individual synaptic link score)\n\n\nsegment_size.parquet\nSize information about a segment such as number of containing supervoxels or total number of voxels\n\n\nsegment_nucleus.parquet\nFor each segment a count of associated number of nuclei. Should only be one in an ideal world with perfect segmentations.\n\n\nsegment_neurotransmitter.parquet\nSummary of most likely neurotransmitter per segment based on filtering of presynaptic locations and their individual neurontransmitter prediction\n\n\nsegment_link_pre.parquet\nNumber of presynaptic locations and downstream partner segments for each segment\n\n\nsegment_link_post.parquet\nNumber of postsynaptic locations and upstream partner segments for each segment\n\n\nlink.parquet/*.parquet\nSame information as in thet synapse_link.parquet file but split into individual parquet files for faster access\n\n\nneurotransmitter.parquet/*.parquet\nThe neurotransmitter predictions for each individual synaptic link\n\n\nnucleus.parquet/*.parquet\nThe location and size of each individual predicted nucleus\n\n\nsynapse_link.parquet\nEach individual predicted synaptic link between a presynaptic and a postsynaptic location with associated scores.\n\n\nskeleton/l2skeletons/skeletons.parquet\nSummary statistics about each exported l2skeleton in the dataset.\n\n\nskeleton/l2skeletons/skeleton_nodes.parquet\nIndividual skeleton nodes for each segment."
  },
  {
    "objectID": "posts/connectome-cloud-analytics/index.html#query-the-data",
    "href": "posts/connectome-cloud-analytics/index.html#query-the-data",
    "title": "Large-Scale Connectome Analytics in the Cloud",
    "section": "Query the Data",
    "text": "Query the Data\nUsing DuckDB, those files can be used remotely as tables in an SQL query. If you want to go into more depth, you can read the DuckDB documentation. Here, we demonstrate a few common queries to get started. In order to improve readability of the query, we store part of the URL in a baseurl variable\n\nimport navis\nimport duckdb\nbaseurl = 'https://api.braincircuits.io/data/fruitfly_fafb_flywire_public'\n\nFirst, we need a DuckDB connection object:\n\ncon = duckdb.connect()\n\nWe can query neurons by a search string easily. If we want to retrieve all neurons which contain BPN string(case-insensitive) in their label column, we use the following query:\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl}/neurons.parquet' \n               WHERE label ILIKE '%BPN%'\n               LIMIT 5\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\nsegment_id\nx\ny\nz\nsoma_x\nsoma_y\nsoma_z\nnucleus_id\nsv_id\nflow\n...\nmorphology_group\ntop_nt_conf\ncell_type\nlabel\nsize_um3\nnr_pre\nnr_downstream_partner\nnr_post\nnr_upstream_partner\nnucleus_nr\n\n\n\n\n0\n720575940624402173\n101863\n31209\n4323\n128144\n23056\n3021\n4367706\n77618374632589286\nefferent\n...\n\n0.958113\nDNpe053\nDNp_R; Part of comprehensive neck connective t...\n2581.600098\n67526\n29564\n16139\n2792\n1\n\n\n1\n720575940628278654\n122736\n35863\n4010\n127752\n24256\n3265\n4373018\n79026093046706888\nintrinsic\n...\nSMPpm1_2\n0.844157\n\norphan-BPN-output\n195.360001\n1812\n958\n544\n205\n1\n\n\n2\n720575940630006267\n122528\n36529\n4022\n122384\n28984\n3898\n3574415\n79026161766195332\nintrinsic\n...\nSMPpm1_4\n0.870921\n\nnew_clone_4; right; new_clone_4; right; BPN-li...\n298.239990\n2913\n1261\n1272\n385\n1\n\n\n3\n720575940627098249\n140000\n23144\n3126\n140000\n23144\n3126\n5577486\n80221468276838352\nintrinsic\n...\nSMPp&v1_posterior_1\n0.795091\nSMPp&v1A_H01\norphan-BPN-output\n1241.989990\n10747\n4063\n6845\n1085\n1\n\n\n4\n720575940618558365\n162592\n77144\n1981\n162592\n77144\n1981\n6912408\n81773222580344887\nintrinsic\n...\n\n0.845792\n\norphan-BPN-output\n1819.329956\n20429\n7895\n13329\n2115\n1\n\n\n\n\n5 rows × 30 columns\n\n\n\nLet’s retrieve the first 5 neurons that have more than 1000 downstream partners and sort by the number of downstream partners. We can use the following query and retrieve the results directly in a Pandas dataframe:\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl}/neurons.parquet' \n               WHERE nr_downstream_partner &gt; 1000 \n               ORDER BY nr_downstream_partner DESC\n               LIMIT 5\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\nsegment_id\nx\ny\nz\nsoma_x\nsoma_y\nsoma_z\nnucleus_id\nsv_id\nflow\n...\nmorphology_group\ntop_nt_conf\ncell_type\nlabel\nsize_um3\nnr_pre\nnr_downstream_partner\nnr_post\nnr_upstream_partner\nnucleus_nr\n\n\n\n\n0\n720575940621280688\n156482\n42275\n3896\n179416\n51040\n3014\n7396453\n81348673921237569\nintrinsic\n...\n\n0.771267\n\nAPL; APL-LHS; APL-LHS; Mushroom Body\n11388.240234\n146255\n51620\n113071\n7052\n1\n\n\n1\n720575940615970783\n158906\n64213\n4347\n127904\n49928\n1289\n4492836\n81561292049294153\nintrinsic\n...\n\n0.655521\n\nCT1; CT1; gabaergic\n16315.629883\n247006\n49134\n144276\n17505\n1\n\n\n2\n720575940629174889\n107560\n34947\n4823\n83352\n47240\n3701\n1813248\n78040862042737270\nintrinsic\n...\n\n0.795262\n\nAPL; Mushroom Body; APL-RHS; APL-RHS\n11757.730469\n163407\n48184\n125189\n6953\n1\n\n\n3\n720575940621675174\n133999\n56333\n1847\n134280\n51872\n1179\n5058804\n79801523353597754\nintrinsic\n...\n\n0.621499\n\nCT1; CT1\n15729.919922\n246711\n47962\n144967\n18119\n1\n\n\n4\n720575940626637002\n121547\n58007\n2243\n144464\n50760\n762\n5741632\n78957235929387973\nintrinsic\n...\n\n0.859750\n\nNone\n6673.060059\n139542\n42196\n67281\n10190\n1\n\n\n\n\n5 rows × 30 columns\n\n\n\nWe can inspect all the columns in the data frame with:\n\ndf.columns\n\nIndex(['segment_id', 'x', 'y', 'z', 'soma_x', 'soma_y', 'soma_z', 'nucleus_id',\n       'sv_id', 'flow', 'side', 'super_class', 'cell_class', 'cell_sub_class',\n       'ito_lee_hemilineage', 'hartenstein_hemilineage', 'nerve', 'fbbt_id',\n       'top_nt', 'status', 'morphology_group', 'top_nt_conf', 'cell_type',\n       'label', 'size_um3', 'nr_pre', 'nr_downstream_partner', 'nr_post',\n       'nr_upstream_partner', 'nucleus_nr'],\n      dtype='object')\n\n\nLet’s display only the number of downstream partners and presynaptic locations:\n\ndf[['segment_id', 'nr_downstream_partner', 'nr_pre']]\n\n\n\n\n\n\n\n\nsegment_id\nnr_downstream_partner\nnr_pre\n\n\n\n\n0\n720575940621280688\n51620\n146255\n\n\n1\n720575940615970783\n49134\n247006\n\n\n2\n720575940629174889\n48184\n163407\n\n\n3\n720575940621675174\n47962\n246711\n\n\n4\n720575940626637002\n42196\n139542\n\n\n\n\n\n\n\nWe see that segment 720575940621280688 has 51620 downstream partners and 146255 presynaptic locations.\nLet’s store this segment id as variable\n\nsegment_id = 720575940621280688\n\nLet’s get all the downstream partners of this segment:\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl}/segment_link.parquet' \n               WHERE src = {segment_id}\n               ORDER BY dst DESC\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\nsrc\ndst\ncount\nmin_scores\nmax_scores\navg_scores\nmin_cleft_scores\nmax_cleft_scores\navg_cleft_scores\n\n\n\n\n0\n720575940621280688\n720575940660053121\n2\n109.382713\n190.875397\n150\n141\n152\n146\n\n\n1\n720575940621280688\n720575940660047489\n43\n7.637001\n742.377136\n192\n1\n178\n114\n\n\n2\n720575940621280688\n720575940659940225\n41\n5.718618\n443.282257\n172\n0\n168\n120\n\n\n3\n720575940621280688\n720575940659850113\n23\n9.563767\n700.225708\n174\n0\n168\n104\n\n\n4\n720575940621280688\n720575940659765121\n31\n9.567139\n1110.103516\n161\n9\n173\n129\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n51615\n720575940621280688\n720575940379705726\n2\n20.213730\n29.862347\n25\n144\n166\n155\n\n\n51616\n720575940621280688\n720575940379590257\n1\n100.210541\n100.210541\n100\n28\n28\n28\n\n\n51617\n720575940621280688\n720575940379312979\n1\n130.753403\n130.753403\n131\n150\n150\n150\n\n\n51618\n720575940621280688\n720575940379312467\n1\n337.480469\n337.480469\n337\n144\n144\n144\n\n\n51619\n720575940621280688\n0\n5\n23.942980\n425.107513\n148\n0\n168\n92\n\n\n\n\n51620 rows × 9 columns\n\n\n\nAnd we get the list of all downstream segments from the dataframe:\n\ndownstream_segments = df['dst'].tolist()\nprint(downstream_segments[:5])\n\n[720575940660053121, 720575940660047489, 720575940659940225, 720575940659850113, 720575940659765121]\n\n\nLet’s get the L2 skeleton of this segment\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl}/skeleton/l2skeletons/skeleton_nodes.parquet' \n               WHERE segment_id = {segment_id}\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\nsegment_id\nx\ny\nz\nnode_id\nparent\n\n\n\n\n0\n720575940621280688\n506832\n182256\n49640\n0\n6\n\n\n1\n720575940621280688\n507232\n181232\n52400\n1\n5\n\n\n2\n720575940621280688\n511488\n155344\n87240\n2\n8\n\n\n3\n720575940621280688\n510192\n173536\n60120\n3\n9\n\n\n4\n720575940621280688\n508864\n175056\n59200\n4\n3\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n11343\n720575940621280688\n720592\n199120\n123600\n11343\n11342\n\n\n11344\n720575940621280688\n721520\n201552\n120360\n11344\n11346\n\n\n11345\n720575940621280688\n724288\n202160\n123520\n11345\n11344\n\n\n11346\n720575940621280688\n724352\n205840\n120680\n11346\n11347\n\n\n11347\n720575940621280688\n720944\n205328\n125480\n11347\n11340\n\n\n\n\n11348 rows × 6 columns\n\n\n\nWe notice that this query is very slow. One option to speed things up is to download the entire skeleton_nodes.parquet file (180MB) and run the query locally:\n!wget -O /tmp/skeleton_nodes.parquet \\\n    https://api.braincircuits.io/data/fruitfly_fafb_flywire_public/skeleton/l2skeletons/skeleton_nodes.parquet \nThe same query now takes only a fraction of a second.\ndf = con.query(f\"\"\"SELECT * \n               FROM '/tmp/skeleton_nodes.parquet' \n               WHERE segment_id = {segment_id}\"\"\").df()\nIf we are interested in advanced neuroanatomical analyses of this neuron based on it’s skeletonized representation, we can use the NAVis package for neuron analysis and visualization.\nIn order to do that, we convert the DataFrame into a format that can be parsed by the SWC reader of NAVis.\n\ndf2 = df.rename(columns={'parent': 'parent_id'})\ndf2['label'] = 0\ndf2['radius'] = 0\n\nThen we convert the DataFrame to a navis.TreeNeuron to get some basic statistics.\n\nswc = navis.read_swc(df2)\nprint(swc)\n\ntype                      navis.TreeNeuron\nname                                   SWC\nn_nodes                              11348\nn_connectors                          None\nn_branches                            1158\nn_leafs                               1761\ncable_length                    42474824.0\nsoma                                  None\nunits                      1 dimensionless\ncreated_at      2023-10-19 18:01:31.521072\norigin                           DataFrame\ndtype: object\n\n\nSee the Tutorials sections on the NAVis website for an overview for further processing of the skeleton.\nGoing back to synaptic data, we can now also retrieve presynaptic locations for this segment with the following query:\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl}/synapse_link.parquet' \n               WHERE pre_segment_id = {segment_id}\n               LIMIT 5\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\nid\npre_x\npre_y\npre_z\npost_x\npost_y\npost_z\nscores\ncleft_scores\ncleft_id\npre_segment_id\npost_segment_id\n\n\n\n\n0\n21210\n135698\n41219\n1850\n135665\n41212\n1849\n170.457611\n141\n9915144\n720575940621280688\n720575940507977460\n\n\n1\n21211\n135709\n41240\n1849\n135680\n41243\n1849\n326.895081\n147\n9915144\n720575940621280688\n720575940507981812\n\n\n2\n21212\n135719\n41259\n1848\n135723\n41279\n1849\n298.207092\n100\n0\n720575940621280688\n720575940507984372\n\n\n3\n21219\n135709\n41226\n1852\n135683\n41234\n1852\n127.513809\n68\n0\n720575940621280688\n720575940605817522\n\n\n4\n22149\n137649\n41189\n1863\n137652\n41207\n1862\n487.758301\n148\n10150849\n720575940621280688\n720575940472242925\n\n\n\n\n\n\n\nOr the postsynaptic locations:\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl}/synapse_link.parquet' \n               WHERE post_segment_id = {segment_id}\n               LIMIT 5\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\nid\npre_x\npre_y\npre_z\npost_x\npost_y\npost_z\nscores\ncleft_scores\ncleft_id\npre_segment_id\npost_segment_id\n\n\n\n\n0\n21253\n135822\n41325\n1862\n135843\n41297\n1862\n10.482904\n0\n0\n720575940507992820\n720575940621280688\n\n\n1\n21277\n135924\n41320\n1873\n135938\n41299\n1873\n910.730591\n142\n9915241\n720575940636560730\n720575940621280688\n\n\n2\n21284\n135971\n41583\n1872\n135968\n41552\n1872\n286.582794\n149\n9915238\n720575940649691513\n720575940621280688\n\n\n3\n21297\n135999\n41502\n1873\n135986\n41526\n1873\n117.003525\n83\n0\n720575940636560730\n720575940621280688\n\n\n4\n21344\n136810\n41444\n1849\n136790\n41461\n1849\n45.242020\n92\n0\n720575940629397079\n720575940621280688\n\n\n\n\n\n\n\nIt is also possible to fetch synaptic locations across a set of segments. Here, we’re fetching more than 800’000 locations with a single query:\n\ndf = con.query(f\"\"\"SELECT count(*) \n               FROM '{baseurl}/synapse_link.parquet' \n               WHERE pre_segment_id in ('720575940621280688','720575940615970783','720575940629174889','720575940621675174')\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\ncount_star()\n\n\n\n\n0\n803379"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Compare regions between datasets on the synaptic level\n\n\n\n\n\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nOct 12, 2023\n\n\nStephan Gerhard\n\n\n\n\n\n\n  \n\n\n\n\nLarge-Scale Connectome Analytics in the Cloud\n\n\n\n\n\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nStephan Gerhard\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/compare-regions/index.html",
    "href": "posts/compare-regions/index.html",
    "title": "Compare regions between datasets on the synaptic level",
    "section": "",
    "text": "How to compute region-based summaries of synaptic data for identified neurons in two datasets and compare between the two"
  },
  {
    "objectID": "posts/compare-regions/index.html#goals",
    "href": "posts/compare-regions/index.html#goals",
    "title": "Compare regions between datasets on the synaptic level",
    "section": "",
    "text": "How to compute region-based summaries of synaptic data for identified neurons in two datasets and compare between the two"
  },
  {
    "objectID": "posts/compare-regions/index.html#datasets",
    "href": "posts/compare-regions/index.html#datasets",
    "title": "Compare regions between datasets on the synaptic level",
    "section": "Datasets",
    "text": "Datasets\nWe will be using two fruitfly ventral nerve cord datasets for the following analysis, namely FANC (fruitfly_fanc_public) and MANC (fruitfly_manc)."
  },
  {
    "objectID": "posts/compare-regions/index.html#data-model",
    "href": "posts/compare-regions/index.html#data-model",
    "title": "Compare regions between datasets on the synaptic level",
    "section": "Data Model",
    "text": "Data Model\nIn both the MANC and FANC dataset, we are provided with a synapse_region.parquet file that links each predicted synaptic location to a region. The region labels is available in the region columns"
  },
  {
    "objectID": "posts/compare-regions/index.html#code",
    "href": "posts/compare-regions/index.html#code",
    "title": "Compare regions between datasets on the synaptic level",
    "section": "Code",
    "text": "Code\nFirst, we load DuckDB, create a connection and set the two baseurls\n\nimport json\nimport duckdb\ncon = duckdb.connect()\n\nbaseurl_fanc = 'https://api.braincircuits.io/data/fruitfly_fanc_public'\nbaseurl_manc = 'https://api.braincircuits.io/data/fruitfly_manc'\n\nWe pick two homologous descending neurons on the left and right side that are matched between the datasets. We produce a string variable where we concatenated the segment IDs for the subsequent queries.\n\nsegments_fanc = [648518346492614075, 648518346478550356]\nsegments_manc = [10118, 10126]\n\nsegids_fanc = ','.join(map(str, segments_fanc))\nsegids_manc = ','.join(map(str, segments_manc))\n\nLet’s get the basic information for those neurons.\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl_fanc}/neurons.parquet' \n               WHERE segment_id in ({segids_fanc})\"\"\").df()\n\nprint(json.dumps(df.to_dict(orient='records'), indent=2))\n\n[\n  {\n    \"cell_id\": 11162,\n    \"x\": 45064,\n    \"y\": 75200,\n    \"z\": 1294,\n    \"cell_id_type\": \"neck connective\",\n    \"sv_id\": 73608180982162608,\n    \"segment_id\": 648518346492614075,\n    \"label\": \"anterior-posterior projection pattern; central neuron; descending; neck connective (right); primary class\"\n  },\n  {\n    \"cell_id\": 10178,\n    \"x\": 34253,\n    \"y\": 75200,\n    \"z\": 1456,\n    \"cell_id_type\": \"neck connective\",\n    \"sv_id\": 73185968584372736,\n    \"segment_id\": 648518346478550356,\n    \"label\": \"Lesser Azevedo et al. 2023; anterior-posterior projection pattern; central neuron; descending; neck connective (left); primary class; publication; uk\"\n  }\n]\n\n\n\ndf = con.query(f\"\"\"SELECT * \n               FROM '{baseurl_manc}/neurons.parquet' \n               WHERE segment_id in ({segids_manc})\"\"\").df()\n\nprint(json.dumps(df.to_dict(orient='records'), indent=2))\n\n[\n  {\n    \"segment_id\": 10118,\n    \"label\": \"TBD\",\n    \"celltype\": \"DNa02\",\n    \"nr_downstream_partner\": 20392,\n    \"nr_post\": 886,\n    \"nr_pre\": 2566,\n    \"nr_upstream_partner\": 886,\n    \"birthtime\": null,\n    \"class\": \"descending neuron\",\n    \"entryNerve\": \"CvC\",\n    \"exitNerve\": \"None\",\n    \"group\": 10118.0,\n    \"hemilineage\": \"None\",\n    \"longTract\": \"ITD\",\n    \"modality\": null,\n    \"origin\": \"brain\",\n    \"positionType\": \"user\",\n    \"predictedNt\": \"acetylcholine\",\n    \"rootSide\": \"RHS\",\n    \"serial\": NaN,\n    \"serialMotif\": null,\n    \"size\": 6179155956,\n    \"somaNeuromere\": null,\n    \"somaSide\": null,\n    \"subclass\": \"xl\",\n    \"subcluster\": NaN,\n    \"synonyms\": null,\n    \"systematicType\": \"DNxl002\",\n    \"tag\": null,\n    \"target\": \"LegNp_R\",\n    \"transmission\": null\n  },\n  {\n    \"segment_id\": 10126,\n    \"label\": \"TBD\",\n    \"celltype\": \"DNa02\",\n    \"nr_downstream_partner\": 20026,\n    \"nr_post\": 880,\n    \"nr_pre\": 2509,\n    \"nr_upstream_partner\": 880,\n    \"birthtime\": null,\n    \"class\": \"descending neuron\",\n    \"entryNerve\": \"CvC\",\n    \"exitNerve\": \"None\",\n    \"group\": 10118.0,\n    \"hemilineage\": \"None\",\n    \"longTract\": \"ITD\",\n    \"modality\": null,\n    \"origin\": \"brain\",\n    \"positionType\": \"user\",\n    \"predictedNt\": \"acetylcholine\",\n    \"rootSide\": \"LHS\",\n    \"serial\": NaN,\n    \"serialMotif\": null,\n    \"size\": 6459395030,\n    \"somaNeuromere\": null,\n    \"somaSide\": null,\n    \"subclass\": \"xl\",\n    \"subcluster\": NaN,\n    \"synonyms\": null,\n    \"systematicType\": \"DNxl002\",\n    \"tag\": null,\n    \"target\": \"LegNp_L\",\n    \"transmission\": null\n  }\n]\n\n\nBefore we go into retrieving more details about the neurons, let’s get an overview of the available regions and their synaptic link count in both datasets.\nFor FANC\n\ncon.execute(f\"\"\"select region, count() as count \n    from '{baseurl_fanc}/synapse_link.parquet' \n    group by region order by region;\"\"\").df()\n\n\n\n\n\n\n\n\nregion\ncount\n\n\n\n\n0\n\n25874\n\n\n1\nAMNp_L\n6991\n\n\n2\nAMNp_R\n1504\n\n\n3\nANm_L\n3390\n\n\n4\nANm_R\n3072\n\n\n5\nCFF_L\n599\n\n\n6\nCFF_R\n37\n\n\n7\nDLT_L\n3181\n\n\n8\nDLT_R\n1012\n\n\n9\nDLV_L\n287\n\n\n10\nDLV_R\n92\n\n\n11\nDMT_L\n4695\n\n\n12\nDMT_R\n5210\n\n\n13\nHTct_L\n73846\n\n\n14\nHTct_R\n28179\n\n\n15\nITD_HC_L\n345\n\n\n16\nITD_HC_R\n45\n\n\n17\nITD_HT_L\n2653\n\n\n18\nITD_HT_R\n196\n\n\n19\nITD_L\n3601\n\n\n20\nITD_R\n340\n\n\n21\nIntTct_L\n46649\n\n\n22\nIntTct_R\n20328\n\n\n23\nLTct_L\n9885\n\n\n24\nLTct_R\n8490\n\n\n25\nMDT_L\n4276\n\n\n26\nMDT_R\n2969\n\n\n27\nMesoNm_L\n7065\n\n\n28\nMesoNm_R\n1405\n\n\n29\nMetaNm_L\n5071\n\n\n30\nMetaNm_R\n3316\n\n\n31\nNTct_L\n12177\n\n\n32\nNTct_R\n3352\n\n\n33\nProNm_L\n15214\n\n\n34\nProNm_R\n5211\n\n\n35\nVLT_L\n1451\n\n\n36\nVLT_R\n460\n\n\n37\nVTV_L\n109\n\n\n38\nVTV_R\n112\n\n\n39\nWTct_L\n203787\n\n\n40\nWTct_R\n94022\n\n\n41\nmVAC_L\n15\n\n\n42\nmVAC_R\n8\n\n\n\n\n\n\n\nAnd in MANC\n\ncon.execute(f\"\"\"select region, count() as count \n    from '{baseurl_manc}/synapse_link.parquet' \n    group by region order by region;\"\"\").df()\n\n\n\n\n\n\n\n\n\n\n\nregion\ncount\n\n\n\n\n0\n&lt;unspecified&gt;\n277813\n\n\n1\nADMN(L)\n26182\n\n\n2\nADMN(R)\n29193\n\n\n3\nANm\n8054040\n\n\n4\nAbN1(L)\n64\n\n\n5\nAbN1(R)\n189\n\n\n6\nAbN2(L)\n1023\n\n\n7\nAbN2(R)\n1357\n\n\n8\nAbN3(L)\n262\n\n\n9\nAbN3(R)\n669\n\n\n10\nAbN4(L)\n3377\n\n\n11\nAbN4(R)\n635\n\n\n12\nAbNT\n1277\n\n\n13\nCV\n92795\n\n\n14\nCvN(L)\n504\n\n\n15\nCvN(R)\n150\n\n\n16\nDMetaN(L)\n6219\n\n\n17\nDMetaN(R)\n2040\n\n\n18\nDProN(L)\n2665\n\n\n19\nDProN(R)\n7267\n\n\n20\nHTct(UTct-T3)(L)\n2030327\n\n\n21\nHTct(UTct-T3)(R)\n2070303\n\n\n22\nIntTct\n3339430\n\n\n23\nLTct\n2836753\n\n\n24\nLegNp(T1)(L)\n9756586\n\n\n25\nLegNp(T1)(R)\n9483421\n\n\n26\nLegNp(T2)(L)\n8777453\n\n\n27\nLegNp(T2)(R)\n9054987\n\n\n28\nLegNp(T3)(L)\n10466926\n\n\n29\nLegNp(T3)(R)\n10157620\n\n\n30\nMesoAN(L)\n1070\n\n\n31\nMesoAN(R)\n1180\n\n\n32\nMesoLN(L)\n8364\n\n\n33\nMesoLN(R)\n13976\n\n\n34\nMetaLN(L)\n6891\n\n\n35\nMetaLN(R)\n6562\n\n\n36\nNTct(UTct-T1)(L)\n889967\n\n\n37\nNTct(UTct-T1)(R)\n942526\n\n\n38\nOv(L)\n1572677\n\n\n39\nOv(R)\n1573774\n\n\n40\nPDMN(L)\n7565\n\n\n41\nPDMN(R)\n5844\n\n\n42\nPrN(L)\n135\n\n\n43\nPrN(R)\n3169\n\n\n44\nProAN(L)\n1452\n\n\n45\nProAN(R)\n3648\n\n\n46\nProCN(L)\n286\n\n\n47\nProCN(R)\n1312\n\n\n48\nProLN(L)\n8770\n\n\n49\nProLN(R)\n21741\n\n\n50\nVProN(L)\n1986\n\n\n51\nVProN(R)\n3788\n\n\n52\nWTct(UTct-T2)(L)\n2052048\n\n\n53\nWTct(UTct-T2)(R)\n1951851\n\n\n54\nmVAC(T1)(L)\n238762\n\n\n55\nmVAC(T1)(R)\n271077\n\n\n56\nmVAC(T2)(L)\n169275\n\n\n57\nmVAC(T2)(R)\n182634\n\n\n58\nmVAC(T3)(L)\n259791\n\n\n59\nmVAC(T3)(R)\n268743\n\n\n\n\n\n\n\nWe see that the nomenclature for the brain regions differet in both datasets.\nWe can now query the synapse_link.parquet table which constains a region column for each dataset to retrieve their information. We’re interested here in the regions where the presynaptic sites are located, i.e. the output region of the neuron.\n\nsegids_fanc = ','.join(map(str, [648518346492614075, 648518346478550356]))\n\ndf = con.query(f\"\"\"SELECT pre_segment_id, post_segment_id, region \n               FROM '{baseurl_fanc}/synapse_link.parquet' \n               WHERE pre_segment_id in ({segids_fanc})\"\"\").df()\ndf\n\n\n\n\n\n\n\n\npre_segment_id\npost_segment_id\nregion\n\n\n\n\n0\n648518346492614075\n648518346481564097\nProNm_R\n\n\n1\n648518346478550356\n648518346480882144\nNTct_L\n\n\n2\n648518346478550356\n648518346480882144\nNTct_L\n\n\n3\n648518346478550356\n648518346478550356\nProNm_L\n\n\n4\n648518346478550356\n648518346487504531\nProNm_L\n\n\n...\n...\n...\n...\n\n\n1178\n648518346478550356\n648518346480882144\nWTct_L\n\n\n1179\n648518346478550356\n648518346471876251\nWTct_L\n\n\n1180\n648518346478550356\n648518346471876251\nWTct_L\n\n\n1181\n648518346492614075\n648518346494780554\nNTct_R\n\n\n1182\n648518346492614075\n648518346494780554\n\n\n\n\n\n1183 rows × 3 columns\n\n\n\nAnd for MANC\n\nsegids_manc = ','.join(map(str, [10118, 10126]))\ndf = con.query(f\"\"\"SELECT pre_segment_id, post_segment_id, region\n               FROM '{baseurl_manc}/synapse_link.parquet' \n               WHERE pre_segment_id in ({segids_manc})\"\"\").df()\ndf\n\n\n\n\n\n\n\n\n\n\n\npre_segment_id\npost_segment_id\nregion\n\n\n\n\n0\n10118\n26238\nLegNp(T3)(R)\n\n\n1\n10118\n21649\nLegNp(T3)(R)\n\n\n2\n10118\n18842\nLegNp(T3)(R)\n\n\n3\n10118\n8347499717\nLegNp(T3)(R)\n\n\n4\n10118\n8347501055\nLegNp(T3)(R)\n\n\n...\n...\n...\n...\n\n\n46583\n10126\n53584693656\nCV\n\n\n46584\n10126\n53584693718\nCV\n\n\n46585\n10126\n53584694189\nCV\n\n\n46586\n10126\n54405400717\nCV\n\n\n46587\n10126\n54405401391\nCV\n\n\n\n\n46588 rows × 3 columns\n\n\n\nNext, we like to get the total count of presynaptic location for each segment and region. We can easily do that byy using the group by in the SQL statement:\n\ncon.query(f\"\"\"SELECT pre_segment_id, region, count(*) as count\n               FROM '{baseurl_fanc}/synapse_link.parquet' \n               WHERE pre_segment_id in ({segids_fanc}) \\\n               GROUP BY region, pre_segment_id \n               ORDER BY pre_segment_id asc, count desc\"\"\").df()\n\n\n\n\n\n\n\n\npre_segment_id\nregion\ncount\n\n\n\n\n0\n648518346478550356\nHTct_L\n221\n\n\n1\n648518346478550356\nProNm_L\n111\n\n\n2\n648518346478550356\nNTct_L\n63\n\n\n3\n648518346478550356\nWTct_L\n59\n\n\n4\n648518346478550356\nIntTct_L\n42\n\n\n5\n648518346478550356\nMesoNm_L\n39\n\n\n6\n648518346478550356\nITD_L\n16\n\n\n7\n648518346478550356\nITD_HT_L\n13\n\n\n8\n648518346478550356\nMetaNm_L\n7\n\n\n9\n648518346478550356\nITD_HC_L\n7\n\n\n10\n648518346478550356\n\n5\n\n\n11\n648518346478550356\nMDT_L\n2\n\n\n12\n648518346478550356\nVLT_L\n1\n\n\n13\n648518346478550356\nANm_L\n1\n\n\n14\n648518346492614075\nHTct_R\n303\n\n\n15\n648518346492614075\nNTct_R\n87\n\n\n16\n648518346492614075\nIntTct_R\n48\n\n\n17\n648518346492614075\nProNm_R\n48\n\n\n18\n648518346492614075\nWTct_R\n26\n\n\n19\n648518346492614075\nITD_R\n22\n\n\n20\n648518346492614075\nMDT_R\n16\n\n\n21\n648518346492614075\nMesoNm_R\n13\n\n\n22\n648518346492614075\nMetaNm_R\n12\n\n\n23\n648518346492614075\nITD_HC_R\n9\n\n\n24\n648518346492614075\nDMT_R\n5\n\n\n25\n648518346492614075\n\n4\n\n\n26\n648518346492614075\nITD_HT_R\n1\n\n\n27\n648518346492614075\nANm_R\n1\n\n\n28\n648518346492614075\nVLT_R\n1\n\n\n\n\n\n\n\nAnd for MANC\n\ncon.query(f\"\"\"SELECT pre_segment_id, region, count(*) as count\n               FROM '{baseurl_manc}/synapse_link.parquet' \n               WHERE pre_segment_id in ({segids_manc}) \n               GROUP BY region, pre_segment_id \n               ORDER BY pre_segment_id asc, count desc\"\"\").df()\n\n\n\n\n\n\n\n\n\n\n\npre_segment_id\nregion\ncount\n\n\n\n\n0\n10118\nLegNp(T1)(R)\n7680\n\n\n1\n10118\nLegNp(T3)(R)\n5150\n\n\n2\n10118\nLegNp(T2)(R)\n4426\n\n\n3\n10118\nHTct(UTct-T3)(R)\n2277\n\n\n4\n10118\nNTct(UTct-T1)(R)\n1788\n\n\n5\n10118\nIntTct\n1438\n\n\n6\n10118\nANm\n398\n\n\n7\n10118\nWTct(UTct-T2)(R)\n243\n\n\n8\n10118\nCV\n42\n\n\n9\n10118\n&lt;unspecified&gt;\n16\n\n\n10\n10126\nLegNp(T1)(L)\n8008\n\n\n11\n10126\nLegNp(T3)(L)\n5251\n\n\n12\n10126\nLegNp(T2)(L)\n4269\n\n\n13\n10126\nHTct(UTct-T3)(L)\n2227\n\n\n14\n10126\nNTct(UTct-T1)(L)\n1477\n\n\n15\n10126\nIntTct\n1365\n\n\n16\n10126\nANm\n474\n\n\n17\n10126\nCV\n33\n\n\n18\n10126\n&lt;unspecified&gt;\n17\n\n\n19\n10126\nWTct(UTct-T2)(L)\n9"
  }
]